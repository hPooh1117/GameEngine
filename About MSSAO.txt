src)
http://slideplayer.com/slide/10323430/
http://www.cs.ubc.ca/labs/imager/tr/2001/keller2001a/keller.2001a.pdf
https://www.cct.lsu.edu/~fharhad/ganbatte/siggraph2007/CD2/content/sketches/0250.pdf
ーーーーーー＜　基本方針 ＞ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
・p上に半球をいくつかのサブ半球に分ける。（小さなサブ半球はより大きなサブ半球に包含される。）
・それぞれの半球に対して、半球内のオクルーダーによって、AOを計算する。
・最終的に、AO値はすべての半球で計算されたうちの最大値となる。

・計算にかかる時間を省くために、より粗い解像度で、サンプル数を少なめに計算する。
・それぞれの半球の解像度を大きな半球ほど粗い解像度で計算する。
（この方法の課題）
　　・より粗い解像度で計算されたAO値では、遮蔽されるべき部分が見逃されたりする。
　　・その分だけ、AO値が高くなる

　　　　　　ＡＯ　　　　低＜ーーー＞高
　　　　　　ＣＯＬＯＲ　黒＜ーーー＞白

　　－＞ヒューリスティックを利用して、埋め合わせ
　　－＞すべての解像度におけるAO値の平均をとり、最大値を調節する。

　　　　　　𝐴 𝑂 𝑓𝑖𝑛𝑎𝑙 = f( max(𝐴 𝑂 𝑖) , average(𝐴 𝑂 𝑖) )
　　　　　　𝐴 𝑂 𝑓𝑖𝑛𝑎𝑙 ≥ max(𝐴 𝑂 𝑖)
　　　　　　𝐴 𝑂 𝑓𝑖𝑛𝑎𝑙 ∝ average(𝐴 𝑂 𝑖)

ーーーーーー＜　MSSAO 概要 ＞ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

１．まず、最も解像度の高いg-bufferを作る。（深度と法線を含む）
２．そこから低解像度のg-bufferを得るために、任意の回数ダウンサンプリングする。

３．最も低解像度のものからすべてのピクセルのAOを計算し、AO bufferに結果を書き込み。
４．AO bufferをブラー処理し、アップサンプリングする。
５．アップサンプリングしたら、その結果は次のレンダリングパスに使用する。
　　次に低解像度のg-bufferについてAOを計算し、アップサンプリングされたものと結合し、次のレベルのAO bufferとして出力する。
６．４．５．を繰り返して、最大解像度まで計算する。最大解像度におけるAO bufferを最終結果として出力する。

※　参考スライドの著者は5段階のダウンサンプリングを行っている。

ーーーーーー＜　Downsample ＞ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー

　　＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
　｜　　　　　　　｜　　　　　　　｜
　｜　　　　　　　｜　　　　　　　｜            p1Z <= p2Z <= p3Z <= p4Z
　｜　　　●　　　｜　　　●　　　｜
　｜　　　ｐ１　　｜　　　ｐ２　　｜            if p4Z - p1Z <= d_threshold
　｜　　　　　　　｜　　　　　　　｜                 p <- (p2 + p3)/2
　｜￣￣￣￣￣￣￣●￣￣￣￣￣￣￣｜                 n <- (n2 + n3)/2
　｜　　　　　　　｜ｐ　　　　　　｜            else
　｜　　　　　　　｜　　　　　　　｜                 p <- p2
　｜　　　●　　　｜　　　●　　　｜                 n <- n2
　｜　　　ｐ３　　｜　　　ｐ４　　｜
　｜　　　　　　　｜　　　　　　　｜
　　￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣


１．低解像度ピクセルｐをもとめるため、最も近い４ピクセルを探す（p1ーp4）そしてLinearZ値にしたがってソートする。
２．4ピクセルのうち、中間の２ピクセルのeye-space coordinatesを取り出し、平均をとり、ｐのeye-space coordinatesとする。
　　（これは4ピクセルのeye-space coordinatesの中央値の近似値として利用）
　　－＞この中央値は4ピクセルの値が顕著に異なる場合、ｐは必ずしも正確ではない。
　　－＞AOの影響する半径を超えたジオメトリにはアーティファクトがつくられてしまう。
　　－＞p1とp4の相互の距離によって調節することで、アーティファクトがつくられなくなる。
　　－＞具体的には、p1とp4の距離が十分大きい場合、4ピクセルのどれか１つのeye-space coordinatesを選択する（上図ではp2）。
　　－＞これにより、アーティファクトが減るだけでなく、よりよいtemporal coherenceがもたらされる。
３．normalについても２．と同様に値を得る。
　　（4ピクセルのnormalのn2, n3の合計値をnormalizeせずに2で割っているのは、normalsをnormalizeする必要がないから。）
　　（実際にこの方法のほうが見た目の良い結果が得られ、アーティファクトが減る。）

ーーーーーー＜ AO buffer ＞ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
AOnear　　　　：近縁ピクセルによって生じたAO
AOfar　　　　 ：遠く離れたピクセルによって生じたアップサンプリングされたAO
AOcombined 　：初回以外の各レンダリング過程で得たAOnearとAOfarを結合したAO

・各解像度でピクセルｐにおけるAOnearを計算するために、ｐのスクリーン空間上での近縁ピクセルをサンプルする。
　（sampling kernel sizeは後述。）
　　１．ビュー空間でAO radius(max値)を設定する。
　　　　occlusionの影響が及びそうにないピクセルまでの距離を設定する。
　　　　この距離は最大解像度Res1でスクリーン空間に投影する。これをr1(p)とする。
　　　　より粗い解像度のmaximum kernel sizeは以下のように決定する。
　　   r0(p) = sdmax / 2ztan(α/2)　（s : 最大解像度時のビューポートdimension、α：カメラのFOV、ｚ：ピクセルｐのeye-space深度)
      ri(p) = r0(p) / 2^i
      Ri(p) = min(rmax, ri(p))

　　２．どの解像度でもradiusの最大値は定数rmaxにおさえる。
　　　　－＞解像度がより高ければ、より半球が小さくなるため。
　　　　－＞ri(p)値はｐがカメラに近いときに大きくなりすぎる可能性があるため。
　　　　－＞パフォーマンスががくっと落ちるので、調整されたサイズまでにkernel radiusをおさめる。

　　　　※論文ではrmax = 5 を使用。これは11x11ピクセルカーネルに対応。

　　３．11x11ピクセルカーネルの全ピクセルをサンプルするわけではなく、そのほかの全てのピクセルのみサンプルする。
　　　　－＞テクセルフェッチ回数を121から36まで減らすことができる。このサンプリングパターンはinterleaved samplingに似ているがランダム性はなし。
　　　　－＞この過程は後のBlurパスにおいて、3x3 pixel neighborhood中のAO値を結合させるのに役に立つ。
　　　　
　　　　・より大域的なAOを使うためにradiusを大きくすると、サンプリングが遅くなる。
　　　　・この場合はlow-variant random sampling patternを利用して修正できる。（poisson disks）
　　　　・論文著者は最大解像度において、16point Poisson diskを利用してサンプリングしている。

　　４．最大解像度では半球の半径が小さいので、Blurパスが不要

// TODO : 11x11 pixel-kernelとは何？？

ーーーーーー＜ AO計算　　　＞ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー
...

・必要技術
sampling scheme
temporal coherence(temporal reprojection)
downsample
ambient occlusion
upsample